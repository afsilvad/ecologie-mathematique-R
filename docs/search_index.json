[
["chapitre-ode.html", "14 Modélisation déterministe 14.1 Équations différentielles 14.2 Les équations différentielles ordinaires en modélisation écologique 14.3 Les équations différentielles partielles en modélisation écologique", " 14 Modélisation déterministe ️ Objectifs spécifiques: À la fin de ce chapitre, vous saurez définir une équation différentielle ordinaire et une équation différentielle partielle saurez aptes à détecter un problème impliquant le besoin d’utiliser des équations différentielles serez en mesure d’effectuer une modélisation impliquant un système d’EDO en contexte écologique De plus, en extra (non évalué, objectif incertain), vous - serez en mesure d’effectuer une modélisation par différences finies impliquant une EDP simple en contexte écologique On se réfère à la modélisation mécanistique lorsque des principes théoriques guident une modélisation, à l’inverse de la modélisation phénoménologique, qui est guidée par les données. Il existe de nombreuses techniques de modélisation mécanistique, mais la plupart sont guidées par les équations différentielles. 14.1 Équations différentielles Les équations différentielles permettent la résolution de problèmes impliquant des gradients dans le temps et dans l’espace. On les utilise pour modéliser la dynamique des populations, la thermodynamique, l’écoulement de l’eau dans les sols, le transport des solutés, etc. On en distingue deux grandes catégories: les équations différentielles ordinaires et partielles. Équations différentielles ordinaires (EDO). Les équations différentielles ordinaires s’appliquent sur des fonctions s’appliquant à une seule variables, qui est souvent le temps. On pourra suivre, par exemple, l’évolution de la température en un point, en fonction du temps à partir d’une condition initiale. Parfois, plusieurs EDO sont utilisées conjointement pour créer un système d’EDO que l’on pourra nommé un système dynamique. Les solutions analytiques des EDO sont parfois relativement faciles à résoudre, mais les ordinateurs permettent des résolutions numériques en quelques lignes de code. Équations différentielles partielles (EDP). Dans ce cas, ce sont plusieurs variables qui sont différenciées dans la même fonction. Il peut s’agir des coordonnées dans l’espace \\([x, y, z]\\) (régime permanent), qui peuvent aussi être appliqués à différents pas de temps (régime transitoire). Le problème sera délimité non pas seulement par des conditions initiales, mais aussi par des conditions aux frontières du modèle. Puisque que les solutions analytiques des EDP peuvent rarement être développées, on utilisera pratiquement toujours des approches numériques que sont principalement les méthodes de résolution par différences finies ou par éléments finis. 14.2 Les équations différentielles ordinaires en modélisation écologique L’évolution des populations dans le temps peut être abordée à l’aide de systèmes d’équations différentielles. Une simple équation décrivant la croissance d’une population peut être couplée à des schémas d’exploitation de cette population, que ce soit une exploitation forestière, une terre fourragère ou un territoire de chasse. On pourra aussi faire interagir des populations dans des schémas de relations biologiques. Ces processus peuvent être implémentés avec des processus aléatoires pour générer des schémas probabilistes. De plus, les biostatistiques et l’autoapprentissage peuvent être mis à contribution afin de calibrer les modèles. 14.2.1 Évolution d’une seule population en fonction du temps La croissance d’une population (ou de sa densité) isolée en fonction du temps dépend des conditions qui lui offre son environnement. Dans le cas de la biomasse d’une culture à croissance constante, le taux de croissance est toujours le même. \\[ \\frac{d 🌿 }{dt} = c \\] \\[ \\int_0^t c dt = \\int_{🌿_0}^{🌿(t)} ~d🌿 \\] \\[ ct = 🌿(t) - 🌿_0\\] \\[ 🌿(t) = 🌿_0 + ct \\] par(mar=c(4, 4, 1, 1), ps=10) y0 &lt;- 2 c &lt;- 2 # exprimé en individu / pas de temps times &lt;- seq(0, 6, 0.1) y &lt;- y0 + c * times plot(times, y, &#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Population&quot;, ylim=c(0, max(y))) text(max(times), max(y), round(max(y))) Dans le cas d’une population qui se reproduit, une formulation simple modélise une évolution linéaire associée à un taux de natalité \\(n\\) et un taux de mortalité \\(m\\), où \\(r = n-m\\) est le taux de croissance de la population d’une population de lapins 🐰 en fonction du temps \\(t\\). \\[ \\frac{d🐰}{dt} = n🐰 - m🐰 = r🐰 \\] \\[ \\int_0^t dt = \\int_{🐰_0}^{🐰(t)} \\frac{1}{r🐰} ~d🐰 \\] \\[ t = \\frac{1}{r} ln(🐰) \\bigg\\rvert_{🐰_0}^{🐰(t)} \\] \\[ rt = ln \\left( \\frac{🐰(t)}{🐰_0} \\right) \\] \\[ 🐰(t) = 🐰_0 exp(rt) \\] La vitesse de croissance est constante pour une population constante, mais la croissance de la population est exponentielle étant donnée que chaque nouvel individu se reproduit. par(mar=c(4, 4, 1, 1), ps=10) y0 &lt;- 10 r &lt;- 0.2 # exprimé en individu / pas de temps times &lt;- seq(0, 10, 0.1) y &lt;- y0 * exp(r*times) plot(times, y, &#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Lapin&quot;, ylim=c(0, max(y))) text(max(times), max(y), round(max(y))) De 10 lapins au départ, nous en avons un peu plus de 75 après 10 ans… et près de 5 milliards après 100 ans! En fait, la capacité de support d’une population étant généralement limitée, on peut supposer que le taux de natalité décroit et que le taux de mortalité croit linéairement avec l’effectif. \\[ n(🐰) = \\alpha - \\beta 🐰 \\] \\[ m(🐰) = \\gamma + \\delta 🐰 \\] On aura donc \\[ \\frac{d🐰}{dt} = 🐰 \\left( \\alpha - \\beta 🐰 \\right) - 🐰 \\left( \\gamma + \\delta 🐰 \\right) = r🐰 \\left( 1 - \\frac{🐰}{K} \\right) \\] où \\(r = \\alpha - \\gamma\\) est l’ordonnée à l’origine du taux de croissance (théorique, lorsque la population est nulle) et \\(K = \\frac{\\alpha-\\gamma}{\\beta + \\delta}\\) est la capacité limite du milieu de subsistance. On pourra s’aider d’un logiciel de calcul symbolique comme sympy ou maxima pour en tirer une solution analytique. Mais à ce point, nous utiliserons une approximation numérique. Nous utiliserons le module deSolve. library(&quot;deSolve&quot;) deSolve demande de définir les paramètres de l’EDO ou du système d’EDO. Nous devons d’abord spécifier à quels pas de temps notre EDO doit être approximée. J’étends la plage de temps à 30 ans pour bien visualiser la courbe de croissance. times &lt;- seq(0, 30, by = 0.5) Les conditions initiales du système d’EDO sont aussi définies dans un vecteur. La seule condition initiale de notre EDO est le nombre initial de lapin. y0 &lt;- c(lapin = 10) On définira les paramètres dans un vecteur p. Dans notre cas, nous avons \\(r\\), le taux de croissance à l’origine et \\(K\\), la capacité de support de l’écosystème. Il est préférable de nommer les paramètres du vecteur pour éviter les erreurs. p &lt;- c(r = 0.2, K = 40) Enfin, une fonction définit l’EDO avec, comme entrées, les pas de temps, les conditions initiales et les paramètres. La sortie de la fonction est un vecteur des dérivées emboîtés dans une liste (lisez le fichier d’aide de la fonction ode pour les détails en lançant ?ode). model_logistic &lt;- function(t, y, p) { lapin &lt;- y[1] dlapin_dt &lt;- p[1] * lapin * (1 - lapin/p[2]) return(list(c(dlapin_dt))) } Une fois que les pas de temps, les conditions initiales, les paramètres et le modèle sont définis, on les spécifie comme arguments dans la fonction ode. La sortie de la fonction ode est une matrice dont la première colonne comprend les pas de temps imposés, et les autres colonnes sont les dérivées spécifiées à la sortie de la fonction ode. lapin_t &lt;- ode(y = y0, times = times, model_logistic, p) head(lapin_t) ## time lapin ## [1,] 0.0 10.00000 ## [2,] 0.5 10.76856 ## [3,] 1.0 11.57342 ## [4,] 1.5 12.41288 ## [5,] 2.0 13.28478 ## [6,] 2.5 14.18643 par(mar=c(4, 4, 1, 1), ps=10) plot(lapin_t[, 1], lapin_t[, 2], type=&#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Lapin&quot;, ylim=c(0, max(lapin_t[, 2]))) Exercice. Que ce passerait-il si le taux de croissance était négatif? Profitez-en pour changer les paramètres r et K. Exercice. D’autres formulations existent pour exprimer des taux de croissance (Gompertz, Allee, etc.). En outre la formulation de Gompertz s’écrit comme suit. \\[ \\frac{d🐰}{dt} = r🐰 \\left( ln \\frac{K}{🐰} \\right) \\] Entrer cet EDO dans R avec deSolve. 14.2.2 Population exploitée L’exploitation d’une population peut être effectuée de différentes manières. D’abord, le prélèvement peut être effectué de manière constante, par exemple dans un élevage ou par la chasse ou la cueillette. Ajoutons un prélèvement constant dans une courbe de croissance logistique. \\[ \\frac{d🐰}{dt} = r🐰 \\left( 1 - \\frac{🐰}{K} \\right) - Q \\] où \\(Q\\) est le quota, ou le prélèvement constant. On pourra aussi effectuer un prélèvement proportionnel à la population. \\[ \\frac{d🐰}{dt} = r🐰 \\left( 1 - \\frac{🐰}{K} \\right) - E🐰 \\] où \\(E\\) est l’effort d’exploitation. Ou bien effectuer une série de prélèvement ponctuels, comme la récolte de plantes fourragères. \\[ \\frac{d🌿}{dt} = c - \\left[ 🌿 - \\gamma \\right] \\bigg\\rvert_{t=a, b, c, d, e, ...} \\] où \\(\\gamma\\) est le reste de la biomasse après la récolte et \\(t=a, b, c, d, e, ...\\) sont les pas de temps où le bloc entre les crochets est actif, c’est-à-dire la période de récolte. La solution analytique d’une culture à croissance constante est plutôt facile à déduire. Les fonctions de prélèvement peuvent être modulées à votre guise. Prenons pour l’exemple un prélèvement constant et une croissance logistique. p &lt;- c(r = 0.2, K = 40, Q = 1) model_logistic_expl &lt;- function(t, y, p) { lapin &lt;- y[1] dlapin_dt &lt;- p[1] * lapin * (1 - lapin/p[2]) - p[3] return(list(c(dlapin_dt))) } lapin_t &lt;- ode(y = y0, times = times, model_logistic_expl, p) par(mar=c(4, 4, 1, 1), ps=10) plot(lapin_t[, 1], lapin_t[, 2], type=&#39;l&#39;, xlab=&quot;An&quot;, ylab=&quot;Lapin&quot;, ylim=c(0, max(lapin_t[, 2]))) Exercice. Modéliser avec un prélèvement proportionnel. L’exploitation ponctuelle, comme la récolte ou l’administration d’une série de traitements, implique l’utilisation d’approches intermittentes. deSolve ignore les changements dans les variables d’état (y) tels que définis dans les dérivés. Pour ce faire, nous devons avoir recours à des évènements dans le jargon de deSolve. Ces évènements doivent être spécifiés dans un data.frame ou une liste. Il est difficile de trouver un exemple générique pour modéliser des évènements. Pour en savoir davantage, je vous invite donc à consulter la fiche d’aide ?events. Dans notre cas, nous allons modéliser une récolte de plantes fourragères. La récolte est déclenchée lorsque le rendement atteint 2 t/ha, et laisser 0.3 t/ha au sol pour assurer le renouvellement pour les coupes subséquentes. Définissons d’abord les entrées du modèles. times &lt;- seq(0, 120, 0.1) p &lt;- c(r = 0.1, K = 2.5) y0 &lt;- c(champ = 0.1) Nous devons définir une fonction root, dont la sortie est une valeur qui déclenchera un évènement lorsque la valeur sera nulle. Dans notre cas, la valeur correspond simplement au rendement moins 2, la quantité au champ y[1]. Notez que d’autres stratégies peuvent être utilisées pour déclencher une récolte, par exemple le pourcentage de floraison qui demanderait des simulations plus poussées. recolte_root &lt;- function(t, y, p) y[1]-2 Puis, lorsque la fonction root est déclenchée, l’évènement ramène la quantité au champs à 1 t/ha, une quantité qui permet de relancer la croissance. recolte_event &lt;- function(t, y, p) { y[1] &lt;- 0.3 return(y) } La fonction du modèle est telle qu’utilisée auparavant: une fonction logistique. recolte &lt;- function(t, y, p) { champ &lt;- y[1] dchamp_dt &lt;- p[1] * champ * (1 - champ/p[2]) return(list(c(dchamp_dt))) } La fonction ode est lancée en entrant les fonction root et events. out &lt;- ode(times = times, y = y0, func = recolte, parms = p, rootfun = recolte_root, events = list(func = recolte_event, root = TRUE), method=&quot;impAdams&quot;) plot(out) Nous pourrons organiser deux récoltes de 1.7 t/ha et une de 2 t/ha pour terminer la saison. Exercice. Qu’adviendrait-il si vous laissiez 0.15 t/ha au champ au lieu de 0.3? Ou si vous laissiez 1 t/ha? Ou si vous déclenchiez une récolte à 2.3 t/ha? Défi. Pouvez-vous modéliser l’ensilage? 14.2.3 Interactions biologiques Les interactions biologiques entre deux espèces à un stade de croissance défini peuvent prendre différentes formes, du mutualisme (les deux espèces bénéficient de la relation) à la compétition (les deux espèces se nuisent) en passant par la prédation ou le parasitisme (une espèce bénéficie de l’autre en lui nuisant) ou le neutralisme (aucun effet). Ces effets sont décrits dans Pringle (2016) en un tableau synthèse. Source: Pringle, E.G. 2016. Orienting the Interaction Compass: Resource Availability as a Major Driver of Context Dependence. Plos Biology. https://doi.org/10.1371/journal.pbio.2000891 Ces interactions peuvent être décrite mathématiquement dans des systèmes d’EDO, ou EDO couplées. Le cas d’étude le plus courant reprend le système d’équation prédateur-proie de Lotka-Volterra, deux auteurs ayant développé de manière indépendante des équations similaires respectivement en 1925 et 1926. Les équations de Lotka-Volterra supposent une croissance illimitée des deux espèces: les proies 🐰 se reproduisent par elles-mêmes (\\(\\alpha 🐰\\)), tandis que les prédateurs 🦊 croissent selon la disponibilité des proies (\\(\\delta 🐰🦊\\)). À l’inverse, la mortalité des proies dépend du nombre de prédateurs (\\(- \\beta 🐰🦊\\)), mais la mortalité des prédateurs est indépendante des proies (\\(- \\gamma 🦊\\)). On obtient ainsi un système d’équation. \\[\\frac{d🐰}{dt} = \\alpha 🐰 - \\beta 🐰🦊 = 🐰 \\left( \\alpha - \\beta 🦊 \\right)\\] \\[\\frac{d🦊}{dt} = \\delta 🐰🦊 - \\gamma 🦊 = 🦊 \\left( \\delta 🐰 - \\gamma \\right) \\] À l’équilibre de 🐰, c’est-à-dire où \\(\\frac{d🐰}{dt} = 0\\), on retrouve \\(🐰=0\\) ou \\(🦊 = \\frac{\\alpha}{\\beta}\\). De même, à l’équilibre de 🦊, on retrouve \\(🦊=0\\) ou \\(🐰 = \\frac{\\gamma}{\\delta}\\). En termes mathématiques, ces équilibre sont des isoclines, des points d’inflexion dans le système d’EDO. Nous allons résoudre les équations de Lotka-Volterra avec deSolve. Rappelons-nous que nous devons définir des pas de temps où approximer les populations (times), des conditions initiales (y0) et des paramètres (p). times &lt;- seq(0, 30, by = 0.1) y0 &lt;- c(lapin = 3, renard = 1) p &lt;- c(alpha = 2, # taux de croissance des lapins (naissance - mortalité, 1/an) beta = 0.8, # taux de prédation des lapins (renard / an) delta = 0.1, # taux de conversion lors de la prédation (lapin / renard) gamma = 0.2) # mortalité naturelle des renards (1/an) On peut calculer d’emblée les isoclines. lapin_iso &lt;- p[4]/p[3] renard_iso &lt;- p[1]/p[2] Nous devons ensuite créer notre modèle. modele_LV &lt;- function(t, y, p) { lapin = y[1] renard = y[2] dlapin_dt = p[1] * lapin - p[2] * lapin * renard drenard_dt = p[3] * lapin * renard - p[4] * renard return(list(c(dlapin_dt, drenard_dt))) } Lançons l’approximation. effectifs_t = ode(y = y0, times = times, modele_LV, p) head(effectifs_t) ## time lapin renard ## [1,] 0.0 3.000000 1.000000 ## [2,] 0.1 3.380961 1.011940 ## [3,] 0.2 3.806028 1.028156 ## [4,] 0.3 4.278154 1.049326 ## [5,] 0.4 4.799633 1.076263 ## [6,] 0.5 5.371673 1.109943 par(mar=c(4, 4, 1, 1), ps=10) plot(effectifs_t[, 1], effectifs_t[, 2], type = &#39;l&#39;, ylim = c(0, max(effectifs_t[, 2])), xlab = &#39;Temps&#39;, ylab = &quot;Nombre d&#39;individus&quot;) # lapins lines(effectifs_t[, 1], effectifs_t[, 3], col = &#39;red&#39;) legend(x=4, y=12, legend=c(&quot;Lapins&quot;, &quot;Renards&quot;), col=c(&quot;black&quot;, &quot;red&quot;), lty=c(1, 1), cex=1.2) Lorsque la population de lapins croit, celle des renards croit à retardement jusqu’à ce que la population de lapin diminue jusqu’à être presque éteinte. Dans ces conditions, la population de renard ne peut plus être soutenue, et décroit, ce qui en retour donne l’opportunité de la population de lapins de resurgir. par(mar=c(4, 4, 1, 1), ps=10) plot(effectifs_t[, 2], effectifs_t[, 3], type = &#39;l&#39;, xlab = &quot;Nombre lapins&quot;, ylab= &quot;Nombre de renards&quot;, xlim = c(0, max(effectifs_t[, 2])), ylim = c(0, max(effectifs_t[, 3]))) # isoclines abline(v=lapin_iso, lty=2, col=&quot;black&quot;) abline(h=renard_iso, lty=2, col=&quot;red&quot;) points(lapin_iso, renard_iso) # condition initiale points(y0[1], y0[2], pch = 16) Les conditions initiales sont responsables de l’amplitude des cycles. En faisant les faisant varier et en portant graphiquement les vecteurs de flux, on peut mieux apprécier l’importance des isoclines, qui séparent la direction que prend la relation entre deux espèces. effectifs_i &lt;- list() lapin_0 &lt;- 1:30 for (i in 1:length(lapin_0)) { y0[1] &lt;- lapin_0[i] effectifs_i[[i]] &lt;- ode(y = y0, times = times, modele_LV, p) offsets &lt;- effectifs_i[[i]][-1, -1] - effectifs_i[[i]][-nrow(effectifs_i[[i]]), -1] colnames(offsets) &lt;- c(&quot;d_lapin&quot;, &quot;d_renard&quot;) effectifs_i[[i]] &lt;- cbind(effectifs_i[[i]][-1, ], offsets) } effectifs_df &lt;- do.call(rbind.data.frame, effectifs_i) library(&quot;plotrix&quot;) plot(effectifs_df[, 2], effectifs_df[, 3], type = &#39;n&#39;, xlab = &quot;Nombre lapins&quot;, ylab= &quot;Nombre de renards&quot;, xlim = c(0, max(effectifs_df[, 2])), ylim = c(0, max(effectifs_df[, 3]))) # isoclines abline(v=lapin_iso, lty=2, col=&quot;black&quot;) abline(h=renard_iso, lty=2, col=&quot;red&quot;) points(lapin_iso, renard_iso) vectorField(u=effectifs_df[, 4], v=effectifs_df[, 5], xpos=effectifs_df[, 2], ypos=effectifs_df[, 3], scale=0.1, headspan=0.05, vecspec=&quot;lonlat&quot;) Nous avons modélisé une relation biologique de prédation. Il existe dans la littérature une panoplie de modèles d’EDO pour décrire les relations biologiques, qui peuvent être modélisés entre plusieurs espèces pour créer des réseaux trophiques complexes. Toutefois, la difficulté de collecter des données en quantité et en qualité suffisante rendent ces modèles difficiles à appréhender. Exercice. Qu’adviendrait-il des populations si l’on prenait plutôt un profil de croissance logistique chez les lapins? \\[\\frac{d🐰}{dt} = r🐰 \\left( 1-\\frac{x}{K} \\right) - \\beta 🐰🦊 \\] \\[\\frac{d🦊}{dt} = \\delta 🐰🦊 - \\gamma 🦊 \\] Exercice. Modéliser une compétition interspécifique où chaque population croit de manière logistique. \\[\\frac{d🐁}{dt} = r_1 🐁 \\left( 1-\\frac{🐁}{K_1} -\\alpha \\frac{🐀}{K_1} \\right) \\] \\[\\frac{d🐁}{dt} = r_2 🐀 \\left( 1-\\frac{🐀}{K_2} -\\beta \\frac{🐁}{K_2} \\right) \\] où \\(r_1\\) et \\(r_2\\) sont les taux de croissances respectifs des 🐁 et des 🐀, ainsi que \\(K_1\\) et que \\(K_2\\) sont les capacités de support des 🐁 et des 🐀. Le coefficient \\(\\alpha\\) décrit l’ampleur de la compétition de 🐀 sur 🐁 et le coefficient \\(\\beta\\) décrit l’ampleur de la compétition de 🐁 sur 🐀 (\\(\\alpha\\) et \\(\\beta\\) sont &gt;= 0). Exercice. Les interactions biologiques forment une bonne introduction aux systèmes d’équations différentielles ordinaires. On fait néanmoins souvent référence aux équations de Lorenz (1963), qui a développé un système d’EDO chaotique depuis trois équations, \\[ X&#39; = aX + YZ, \\] \\[ Y&#39; = b \\left(Y-Z\\right), \\] \\[ Z&#39; = -XY + cY - Z, \\] où \\(X\\) est la température horizontale, \\(Y\\) est la température verticale, \\(Z\\) est le flux de chaleur convectif, et où l’on retrouve les paramètres \\(a = -8/3\\), \\(b=-10\\) et \\(c=28\\). Résoudre les équations de Lorents avec deSolve. Porter graphiquement les relations entre X, Y et Z. 14.3 Les équations différentielles partielles en modélisation écologique Contrairement aux EDO, la solution des équations différentielle partielles (EDP) dépend de plus d’une variable indépendante. Typiquement, elles dépendent de coordonnées spatiales. Elles peuvent aussi dépendre du temps. Dans cette section, nous allons explorer les régimes permanents, c’est-à-dire indépendants du temps, en utilisant la méthode des différences finies. Nous allons aussi explorer les problèmes transitoires, qui eux dépendent du temps, en utilisant la méthode des lignes. À venir… "]
]

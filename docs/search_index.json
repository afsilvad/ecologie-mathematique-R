[
["chapitre-geo.html", "13 Les données géospatiales 13.1 Les données spatiales 13.2 Le module ggmap 13.3 Types de données spatiales 13.4 Les choroplèthe 13.5 Les rasters 13.6 Autoapprentissage spatial 13.7 Les objets spatialisés en R 13.8 Les systèmes de coordonnées 13.9 Manipuler des tableaux sf 13.10 Manipuler des objets raster 13.11 Graphiques d’objets spatialisés 13.12 Ressources complémentaires", " 13 Les données géospatiales ️ Objectifs spécifiques: À la fin de ce chapitre, vous saurez cartographier des données géoréférencées avec ggplot serez en mesure d’effectuer un autoapprentissage spatial saurez utiliser R comme outil d’analyse spatiale (donnée associées à des points, lignes, polygones et rasters) 13.1 Les données spatiales Des données associées à un endroit sont spatiales. Puisque ce cours ne traite pas d’écologie exoplanétaire, nous traiterons en particulier de données géospatiales, mot que l’on utilise pour désigner des données avec référence spatiale sur la planète Terre. Lorsque nous avons abordé les séries temporelles, j’ai pris pour acquis que nous utilisions le calendrier grégorien comme référence temporelle. Pour les données géospatiales, nous utilisons souvent des angles donnant la position à la surface d’un ellipsoide de révolution (le système géodésique): la longitude décrivant l’angle de part et d’autre (entre 0° et 180° Ouest ou Est) du méridien de référence (le premier méridien, près de Greenwich) et la latitude décrivant l’angle entre l’équateur et l’un des pôles (entre 0° et 90° Nord ou Sud). Les angles sont parfois exprimées sous forme degré° minute' seconde'' Sens cardinal, par exemple 46° 53' 21.659'' S. Toutefois, il est plus commun (et plus pratique) d’exprimer les angles de manière décimale, accompagnée d’un signe pour indiquer le sens cardinal (par convention positif au Nord et à l’Est). Par exemple, sous forme: \\[ secondes = \\frac{21.659&#39;&#39;}{3600&#39;&#39; \\cdot °^{-1}} = 0.00602° \\] \\[ minutes = \\frac{53&#39;}{60&#39; \\cdot °^{-1}} = 0.883° \\] \\[ - \\left( 46° + 0.883° + 0.00602° \\right) = -46.889° \\] La référence de l’altitude est généralement donnée par rapport à un géoïde, qui est une élévation théorique du niveau de la mer ainsi qu’une direction de la gravité évaluée sur toute la surface du globe. Les angles ne sont pas pratiques pour mesurer des distances. Ainsi, pour présenter la Terre sous forme de carte, on cré des représentations applaties du globe sous forme de carte avec l’aide d’équations de projection. Or, il existe différents systèmes géodésiques, différents géoides et de nombreuses manières de calculer les projections. Ainsi, il est important de spécifier les références utilisées lorsque l’on donne dans la précision. Néanmoins, je prendrai pour acquis que vous possédez certaines bases en positionnement, qui ne sont pas essentielles pour suivre le cours, mais qui le sont pour pratiquer adéquatement un métier scientifique. Dans ce chapitre, j’utiliserai comme exemple d’application des donnes météorologiques soutirées d’Environnement Canada grâce au module weathercan, obtenues entre les longitudes -60° et -80° et entre les latitudes 45° et 50° en mai 2018. J’ai effectué quelques opérations pour obtenir des indicateurs météo: degrés-jour (somme des degrés de température moyenne &gt; 5 °C, degree_days), précipitations totales (cumul_precip) et indice de diversité des précipitations (plus l’indice sdi s’approche de 1, plus les températures sont uniformément distribuées pendant la période). Les calculs sont consignés dans le fichier lib/12_weather-fetch.R, mais étant donné que le téléchargement prend pas mal de temps, j’ai créé un csv. Les coordonnées se trouves dans les colonnes de latitude (lat) et longitude (lon). library(&quot;tidyverse&quot;) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.1.0 ✔ purrr 0.3.2 ## ✔ tibble 2.1.1 ✔ dplyr 0.8.0.1 ## ✔ tidyr 0.8.3 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() source(&quot;lib/12_weather-fetch.R&quot;) weather &lt;- read_csv(&quot;data/12_weather.csv&quot;) ## Parsed with column specification: ## cols( ## station_id = col_double(), ## station_name = col_character(), ## prov = col_character(), ## lat = col_double(), ## lon = col_double(), ## degree_days = col_double(), ## cumul_precip = col_double(), ## sdi = col_double() ## ) weather %&gt;% head() ## # A tibble: 6 x 8 ## station_id station_name prov lat lon degree_days cumul_precip sdi ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10247 ILE AUX GRU… QC 47.1 -70.5 NA NA NA ## 2 10661 NORTHEAST M… NS 46.4 -61.0 372. 222. 0.904 ## 3 10732 NICOLET QC 46.2 -72.7 823. 78.4 0.704 ## 4 10761 MCTAVISH QC 45.5 -73.6 915. 107 0.740 ## 5 10762 STE-CLOTILDE QC 45.2 -73.7 860. 85.2 0.820 ## 6 10763 ILES DE LA … QC 47.4 -61.8 326. 167. 0.853 Dans le tableau weather, chaque observation est liée à un point dans l’espace. Dans ce cas, nous avons tous les outils nécessaires pour afficher nos points dans l’espace (figure 13.1). weather %&gt;% ggplot(mapping = aes(x = lon, y = lat)) + geom_point() Figure 13.1: Position des stations météo du tableau weather Si vous avez un oeil averti, vous avez peut-être repéré le Québec, le Nouveau-Brunswick et la frontière avec les États-Unis. L’absence de repère rend néanmoins difficle l’interprétation de cette carte. 13.2 Le module ggmap Le module ggmap ajoute des couches d’images téléchargées depuis des services de cartorgaphie en ligne. Dans cette section, nous allons utiliser le serveice de carte Stamen, qui ne demande pas de frais d’utilisation ou d’enregistrement particulier. La fonction get_stamenmap() demande une boîte de coordonnées délimitant la carte à produire, un paramètre de zoom (plus le zoom est élevé, plus la carte incluera de détails: un zoom de 2 est suffisant pour une carte du monde, mais pour l’Est du Canada, on prendra plutôt un zoom de 6 - un bon zoom est obtenu par tâtonnement) et accessoirement un type de carte. library(&quot;ggmap&quot;) east_canada &lt;- get_stamenmap(bbox = c(left=-81, right = -59, bottom = 44, top = 51), zoom = 6, maptype = &quot;terrain&quot;) Pour afficher la carte, nous enchâssons notre objet dans une fonction ggmap(), à laquelle nous pouvons ajouter une couche. ggmap(east_canada) + geom_point(data = weather, mapping = aes(x = lon, y = lat)) Une approche plus généraliste consiste à spécifier dans la fonction ggmap() l’agument de base utilisé pour lancer un graphique ggplot, comme à la figure figure ??. En outre, l’utiliation de l’argument base_layer permet d’effectuer des fecettes et d’éviter de spécifier la source des données dans toutes les couches subséquentes. ggmap(east_canada, base_layer = ggplot(weather, aes(x = lon, y = lat))) + geom_point() Figure 13.2: Position des stations météo du tableau weather superposé à une carte importée par ggmap La carte que nous avons créée est de type terrain, un type d’affichage efficace mais peu approprié pour une publication visant à être imprimée. Le type toner-lite est davantage voué à l’impression, alors que le type watercolor est plus joli pour le web. Les types offerts sont listés dans la ficher d’aide ?get_stamenmap. maptype = c(&quot;terrain&quot;, &quot;terrain-background&quot;, &quot;terrain-labels&quot;, &quot;terrain-lines&quot;, &quot;toner&quot;, &quot;toner-2010&quot;, &quot;toner-2011&quot;, &quot;toner-background&quot;, &quot;toner-hybrid&quot;, &quot;toner-labels&quot;, &quot;toner-lines&quot;, &quot;toner-lite&quot;, &quot;watercolor&quot;) 13.3 Types de données spatiales Nous avons jusqu’à présent utilisé des données spatiales attchées à un point. Ce ne sont pas les seuls. Données ponctuelles: associées à un point. Exemple: mesure à un endroit précis. Données linéaires: associées à une série de point. Exemple: mesure associée à une route ou une rivière. Données de polygone: associées à une aire délimitée par des points. Exemples: Données associées à un champ, une unité administrative, un bassin versant, etc. Données raster: associées à une grille. Exemple: une image satellite où chaque pixel est associé à un recouvrement foliaire. L’enregistrement des données ponctuelles ne posent pas de défi particulier. Les données associées à un ligne, toutefois posent un problème d’organisation, puisqu’une ligne elle-même contient des informations sur les coordonnées de ses points ainsi que l’ordre dans lequel les points sont connectés. On pourra soit créer un tableau de données ayant une colonne où l’identifiant de la line est consigné, renvoyant à un autre tableau où chaque ligne décrit un point en terme d’identifiant de ligne à laquelle il appartient, ses coordonnées, ainsi que sont ordre de rattachement dans la ligne. Les informations de la ligne pourraient aussi être enchâssées dans une cellule de tableau de données, en tant que sous-tableau. Ou bien, on pourrait créer un tableau sous forme de jointure entre le tableau des données et le tableau des lignes. Un défi similaire pourrait subvenir avec des polygones, qui demandent davantage d’information étant donnée qu’ils peuvent être troués ou séparés en différents morceaux. Enfin, il existe des formats de données spatiales génériques (shapefiles et geojson) ou spécialement conçus pour R (notamment offerts par le module sp), que nous couvrirons plus loin dans ce chapitre. 13.4 Les choroplèthe Les cartes de type choroplèthe se présente sous forme de polygones décrits par un groupe et un ordre, dont un attribu (souvent la couleur de remplissage) dépend d’une covariable. Les pays, par exemple, forment des polygones. world &lt;- map_data(map = &quot;world&quot;) # jeu de donneés de ggplot2 ## ## Attaching package: &#39;maps&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## map head(world) ## long lat group order region subregion ## 1 -69.89912 12.45200 1 1 Aruba &lt;NA&gt; ## 2 -69.89571 12.42300 1 2 Aruba &lt;NA&gt; ## 3 -69.94219 12.43853 1 3 Aruba &lt;NA&gt; ## 4 -70.00415 12.50049 1 4 Aruba &lt;NA&gt; ## 5 -70.06612 12.54697 1 5 Aruba &lt;NA&gt; ## 6 -70.05088 12.59707 1 6 Aruba &lt;NA&gt; La fonction map_data() de ggplot2 permet de soutirer des polygone de certaines cartes. Pour les zones géographiques prédéfinies, il est préférable de soutirer les polygones désirées de données existantes. Toutefois, ces polygones ne sont pas directement disponibles en R. Dans ce cas, il faudra trouver des fichiers de carte auprès de Statistique Canada, Données Québec, etc. especes_menacees &lt;- read_csv(&#39;data/WILD_LIFE_09012019174644084.csv&#39;) iucn_oecd &lt;- especes_menacees %&gt;% dplyr::filter(IUCN == &#39;THREATENED&#39;) %&gt;% dplyr::select(Country, Value) %&gt;% group_by(Country) %&gt;% summarise(n_threatened_species = sum(Value)) %&gt;% arrange(desc(n_threatened_species)) Les noms des pays doivent correspondre exactement, et la colonne des pays doit porter le même nom (j’ai inspecté les vecteurs iucn_oecd30$Country et unique(world$region)). iucn_oecd &lt;- iucn_oecd %&gt;% replace(.==&quot;United States&quot;, &quot;USA&quot;) %&gt;% replace(.==&quot;Slovak Republic&quot;, &quot;Slovakia&quot;) %&gt;% replace(.==&quot;United Kingdom&quot;, &quot;UK&quot;) %&gt;% rename(&quot;region&quot; = &quot;Country&quot;) Les espèces sont jointes au tableau contenant les polygones. world_iucn &lt;- world %&gt;% left_join(iucn_oecd, by = &quot;region&quot;) Pour le graphique, La stratégie est de créer des polygones groupés par groupes de polygones (group = group), dont la couleur de remplissage correspond à au nombre d’espèce. J’ajoute coord_map() en spécifiant une projection de type Mercator (essayez projection = &quot;ortho&quot;). Le reste est de la décoration. ggplot(world_iucn, aes(long, lat)) + geom_polygon(aes(group = group, fill = n_threatened_species), colour = &quot;grey50&quot;, lwd = 0.1) + coord_map(projection = &quot;mercator&quot;, xlim = c(-180, 180), ylim = c(-90, 90)) + scale_fill_gradient(low = &quot;#8CBFE6&quot;, high = &quot;#FF0099&quot;, na.value = &quot;grey80&quot;) + labs(title = &quot;Number of threatened species in OECD countries&quot;, subtitle = &quot;Source: OCDE, 2019&quot;) + theme(panel.background = element_rect(fill = &quot;grey97&quot;), plot.background = element_rect(fill = &quot;white&quot;), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), panel.grid = element_blank()) + guides(fill = guide_legend(title = &quot;Number of\\nthreatened\\nspecies&quot;)) Comme c’est le cas des points, on peut superposer des choroplèthes à des cartes téléchargées (figure 13.3). ## Source : http://tile.stamen.com/watercolor/2/0/0.jpg ## Source : http://tile.stamen.com/watercolor/2/1/0.jpg ## Source : http://tile.stamen.com/watercolor/2/2/0.jpg ## Source : http://tile.stamen.com/watercolor/2/3/0.jpg ## Source : http://tile.stamen.com/watercolor/2/0/1.jpg ## Source : http://tile.stamen.com/watercolor/2/1/1.jpg ## Source : http://tile.stamen.com/watercolor/2/2/1.jpg ## Source : http://tile.stamen.com/watercolor/2/3/1.jpg ## Source : http://tile.stamen.com/watercolor/2/0/2.jpg ## Source : http://tile.stamen.com/watercolor/2/1/2.jpg ## Source : http://tile.stamen.com/watercolor/2/2/2.jpg ## Source : http://tile.stamen.com/watercolor/2/3/2.jpg ## Source : http://tile.stamen.com/watercolor/2/0/3.jpg ## Source : http://tile.stamen.com/watercolor/2/1/3.jpg ## Source : http://tile.stamen.com/watercolor/2/2/3.jpg ## Source : http://tile.stamen.com/watercolor/2/3/3.jpg ## Coordinate system already present. Adding new coordinate system, which will replace the existing one. Figure 13.3: Nombre d’espèces en danger dans les pays de l’OCDE superposé à une carte importée par ggmap Si vous savez créer des polygones, vous saurez créer des lignes de manière similaire avec la couche graphique geom_path(). Pour les rasters, c’est moins évident. 13.5 Les rasters Les rasters sont des données associées à un grille. Nous avons introduis la fonction expand.grid() au chapitre 12 lorsque nous désirions créer un tableau où chaque ligne désigne une des combinaisons possibles d’hyporparamètres pour ajuster un modèle d’autoapprentissage. De même, nous pouvons créer une grille de combinaisons de longitudes et de latitudes et créer une variable spatialisée \\(z = 10\\times sin \\left( xy \\right) - 0.01x^2 + 0.05y^2\\). grid &lt;- expand.grid(lon = seq(from = -80, to = -60, by = 0.25), lat = seq(from = 45, to = 50, by = 0.25)) grid &lt;- grid %&gt;% mutate(z = 10*sin(lon*lat) - 0.01*lon^2 + 0.05*lat^2) # créer une variable spatialisée skimr::skim(grid) # vu au chapitre sur les tableaux ## Skim summary statistics ## n obs: 1701 ## n variables: 3 ## ## ── Variable type:numeric ─────────────────────────────────────────────────────── ## variable missing complete n mean sd p0 p25 p50 p75 ## lat 0 1701 1701 47.5 1.51 45 46.25 47.5 48.75 ## lon 0 1701 1701 -70 5.85 -80 -75 -70 -65 ## z 0 1701 1701 63.61 12.85 28.97 54.51 63.97 72.76 ## p100 hist ## 50 ▇▇▅▇▅▇▅▇ ## -60 ▇▇▇▇▇▇▇▇ ## 95.81 ▁▂▅▇▇▇▃▁ Pour visualiser une grille avec ggplot2, on peut avoir recourt à la couche graphique geom_tile(), dont la couleur remplissage est associée à la colonne z du tableau. Ce type de graphique est appelée heatmap. ggplot(grid, aes(lon, lat)) + geom_tile(aes(fill = z)) Remarquez que j’ai créé une fonction pour générer une variable spatialisée. Une telle fonction n’a pas besoin d’être inventée. On peut en créer une en utilisant les outils que nous avons appris jusqu’à présent, en particulier l’autoapprentissage. 13.6 Autoapprentissage spatial Les géostatistiques est l’étude statistique des variables spatialles. C’est un sujet complexe qui sort du cadre de ce cours, que vous pourrez creuser dans le livre Applied Spatial Data Analysis with R. Ici, nous allons intrapoler des variables spatialisées à l’aide de l’autoapprentissage, où la position (coordonnées en longitude et lattude, par exemple) peut servir de variable prédictive (ainsi que, éventuellement, des variables spatialisées concenrannt l’altitude, l’hydrologie, la géomorphologie, l’écologie, la sociologie, liées à la gestion, etc.). Pour ce faire, vous pourrez utiliser algorithme qui convient à vos données et à votre domaine d’étude (Kanevski et al., 2008). En outre, les processus gaussiens sont particulièrement utiles pour évaluer l’incertitude des prédiction. Pour évaluer la performance d’une prédiction, n’oublions de séparer nos données en jeu d’entraînement et en jeu de test! Par exemple, nous allons prédire sur une grille les données de degrés-jour du tableau weather avec un processus gaussien. library(&quot;caret&quot;) ## Loading required package: lattice ## ## Attaching package: &#39;caret&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## lift weather_dd &lt;- weather %&gt;% select(lon, lat, degree_days) %&gt;% drop_na() weather_dd_sc &lt;- weather_dd %&gt;% mutate(degree_days = (degree_days - mean(degree_days))/sd(degree_days)) train_id &lt;- createDataPartition(y = weather_dd_sc$degree_days, p = 0.7, list = FALSE) library(&quot;kernlab&quot;) ## ## Attaching package: &#39;kernlab&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## cross ## The following object is masked from &#39;package:ggplot2&#39;: ## ## alpha dd_gp &lt;- gausspr(x = weather_dd_sc[train_id, c(&quot;lon&quot;, &quot;lat&quot;)], y = weather_dd_sc[train_id, &quot;degree_days&quot;], kernel = &quot;rbfdot&quot;, #kpar = list(sigma = 01), variance.model = TRUE, scale = TRUE, var = 0.1, cross = 5) ## Using automatic sigma estimation (sigest) for RBF or laplace kernel pred_dd_tr &lt;- predict(dd_gp) pred_dd_te &lt;- predict(dd_gp, newdata = weather_dd_sc[-train_id, c(&quot;lon&quot;, &quot;lat&quot;)]) par(mfrow = c(1, 2)) plot(weather_dd_sc$degree_days[train_id], pred_dd_tr, main = &quot;Train prediction&quot;) abline(0, 1, col=&quot;red&quot;) plot(weather_dd_sc$degree_days[-train_id], pred_dd_te, main = &quot;Test prediction&quot;) abline(0, 1, col=&quot;red&quot;) La prédiction n’est pas extraordinaire, mais gardons-la pour l’exemple (j’ai essayé avec des réseaux neuronaux sans plus de succès). La prochaine étape est de créer une gille où chaque point [longitude, latitude] servra à calculer les degrés-jour. grid &lt;- expand.grid(lon = seq(from = -80, to = -60, by = 0.25), lat = seq(from = 45, to = 50, by = 0.25)) grid &lt;- grid %&gt;% mutate(pred_dd_mean = predict(dd_gp, newdata = ., type = &quot;response&quot;) * sd(weather_dd$degree_days) + mean(weather_dd$degree_days), pred_dd_sd = predict(dd_gp, newdata = ., type = &quot;sdeviation&quot;) * sd(weather_dd$degree_days)) head(grid) ## lon lat pred_dd_mean pred_dd_sd ## 1 -80.00 45 671.9539 66.09015 ## 2 -79.75 45 655.5219 58.62874 ## 3 -79.50 45 637.3732 52.07970 ## 4 -79.25 45 618.0383 46.59139 ## 5 -79.00 45 598.1187 42.25017 ## 6 -78.75 45 578.2647 39.04893 Utilisons les polygones de la carte du monde zoomée à l’endroit qui nous intéresse, et ajoutons-y notre prédiction superposée par les localisation des stations météo. J’ajoute des contours ainsi que des étiquettes de contours (ce qui nécessite le module metR). Les processus gaussien permettent de juxtaposer une carte des écart-type des prédictions, donnant une appréciation de la précision du modèle. Cette juxtaposition est effectuée avec la fonction plot_grid() le module cowplot. library(&quot;metR&quot;) gg_mean &lt;- ggplot(grid, aes(x = lon, y = lat)) + xlim(c(-80, -60)) + ylim(c(45, 50)) + coord_equal() + geom_tile(aes(fill = pred_dd_mean)) + geom_contour(data = grid, mapping = aes(x = lon, y = lat, z = pred_dd_mean), binwidth = 50, colour = &quot;black&quot;, lwd = 0.2) + geom_label_contour(aes(z = pred_dd_mean)) + geom_path(data = world, aes(x = long, y = lat, group = group)) + geom_point(data = weather, mapping = aes(x = lon, y = lat), size = 0.1) + scale_fill_gradient(low = &quot;#8CBFE6&quot;, high = &quot;#FF0099&quot;, na.value = &quot;grey80&quot;) gg_sd &lt;- ggplot(grid, aes(x = lon, y = lat)) + xlim(c(-80, -60)) + ylim(c(45, 50)) + coord_equal() + geom_tile(aes(fill = pred_dd_sd)) + geom_contour(data = grid, mapping = aes(x = lon, y = lat, z = pred_dd_sd), binwidth = 50, colour = &quot;black&quot;, lwd = 0.2) + geom_label_contour(aes(z = pred_dd_sd)) + geom_path(data = world, aes(x = long, y = lat, group = group)) + geom_point(data = weather, mapping = aes(x = lon, y = lat), size = 0.1) + scale_fill_gradient(low = &quot;#8CBFE6&quot;, high = &quot;#FF0099&quot;, na.value = &quot;grey80&quot;) cowplot::plot_grid(gg_mean, gg_sd, labels = c(&quot;A&quot;, &quot;B&quot;), nrow = 2) ## Warning: Removed 93363 rows containing missing values (geom_path). ## Warning: Removed 93363 rows containing missing values (geom_path). 13.7 Les objets spatialisés en R Nous avons vu le type d’objet ts pour les séries temporelles. De même, le type d’objet sf est spécialisé dans les objets georéférencés. Les formats de données spatiales conventionnellement utilisés en R depuis 2003 sont offerts par le module sp. Ce format héritait de difficultés, récemment surmontées par le module sf, plus convivial et mieux adapté au tidyverse. Bien que sp soit plus largement documenté, sf est suffisamment mature pour une utilisation professionnelle. Nous avons vu quatre types de données spatiales. Nous allons maintenant les traiter en deux catégories: les données vectorielle, comprenant les points, lignes et polygones et les données raster, comprenant les grilles de données. 13.7.1 Données vectorielles (points, lignes et polygones) Souvent, nous importerons des polygones existants pour y effectuer des statistiques. On pourra télécharger des données géographiques, puis dézipper les fichier manuellement. Mais pourquoi se casser la tête alors qu’on peut copier un lien, le coller dans R et déziper automatiquement! Le block de code suivant télécharge un dossier de shapefiles décrivant les polygones des régions administratives du Québec. download.file(&quot;ftp://ftp.mrnf.gouv.qc.ca/public/dgig/produits/bdga5m/vectoriel/region_admin_SHP.zip&quot;, destfile=&quot;data/12_quebec/12_region_admin_SHP.zip&quot;) unzip(&quot;data/12_quebec/12_region_admin_SHP.zip&quot;, exdir = &quot;data/12_quebec/&quot;) Pour charger des shapefiles en format sf, nous utilisons la fonction st_read() pointant vers le fichier .shp. library(&quot;sf&quot;) ## Linking to GEOS 3.6.2, GDAL 2.3.2, PROJ 5.1.0 quebec &lt;- st_read(&quot;data/12_quebec/region_admin_polygone.shp&quot;) ## Reading layer `region_admin_polygone&#39; from data source `/home/essi/GitHub/ecologie-mathematique-R/data/12_quebec/region_admin_polygone.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 21 features and 10 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -79.7625 ymin: 44.99136 xmax: -56.93495 ymax: 62.58217 ## epsg (SRID): 4269 ## proj4string: +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs head(quebec) ## Simple feature collection with 6 features and 10 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -79.7625 ymin: 48.04944 xmax: -56.93495 ymax: 62.58217 ## epsg (SRID): 4269 ## proj4string: +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ## AREA PERIMETER REGIO_S_ REGIO_S_ID RES_NO_IND ## 1 1.240869e+02 94.6754067 2 1 50 02 0100 000 ## 2 7.530857e-04 0.1519356 3 2 50 02 0100 000 ## 3 4.460926e+01 55.8047474 4 3 50 02 0100 000 ## 4 5.028808e-01 8.8274338 5 4 50 02 0100 000 ## 5 8.779790e-02 2.0259021 6 5 50 02 0100 000 ## 6 3.813094e+00 22.6943449 7 2 50 02 0100 000 ## RES_DE_IND RES_CO_REG RES_NM_REG RES_CO_REF RES_CO_VER ## 1 Région administrative 10 Nord-du-Québec BDGA5M V2017-06 ## 2 Région administrative 09 Côte-Nord BDGA5M V2017-06 ## 3 Région administrative 09 Côte-Nord BDGA5M V2017-06 ## 4 Région administrative 09 Côte-Nord BDGA5M V2017-06 ## 5 Région administrative 09 Côte-Nord BDGA5M V2017-06 ## 6 Région administrative 09 Côte-Nord BDGA5M V2017-06 ## geometry ## 1 POLYGON ((-77.80893 62.4465... ## 2 POLYGON ((-66.6878 55.00005... ## 3 POLYGON ((-70.02987 55.0000... ## 4 POLYGON ((-66.25978 55.0000... ## 5 POLYGON ((-67.2192 55.00003... ## 6 POLYGON ((-63.60572 52.8760... L’objet comprend des métadonnées sur le type de géométrie (geometry type: POLYGON), les limites des objets (bbox: ...) système de référence (proj4string: ...) ainsi que le tableau descriptif. Nous avons vu au chapitre 3 qu’il est préférable d’éviter la répétition de l’information. Or, dans le format tibble que nous avons utilisé jusqu’ici, l’information attachée à un polygone est répétée pour chaque point qui le compose. Ainsi, forcer une information hiérarchisée à se conformer à une structure rectangulaire multiplie la quantité d’information. Dans le format sf, la colonne geometry comprend dans chacune des cellules, exprimée sous forme de liste, toute l’information nécessaire à la construction d’un polygone. En guise d’exploration rapide, la fonction plot() affichera les vecteurs colorés selon les autres variables du tableau. plot(quebec) Si nous ne désirons que la géométrie, plot(quebec %&gt;% select(geometry)) # ou bien plot(st_geometry(quebec)) Exercice. Explorer l’objet quebec, en particulier la colonne geometry, notamment en utilisant la fonction str(). Vous pourrez soutirer les informations du système de coordonnées avec la fonction st_crs(). Il est possible de calculer des attributs des géométries à l’aide des fonctions st_area() pour les polygones, ou st_length() pour les lignes et les polygones et la fonction st_centroid() pour trouver le centroïde d’un polygone - à cette étape, il se pourrait que R vous demande d’installer le module lwgeom: suivez ses consignes! L’aire et le périmètre ne correspondent pas tout à fait. Les calculs sont peut-être effectués différemments (par exemple, les superficies considérées pour AREA et PERIMETER sont peut-être seulement les superficies terrestres - je n’ai pas vérifié à ce stade de développement de ces notes de cours). La fonction st_centroid() crée un nouveau tableau dont la géométrie est le POINT, elle doit donc être passée après les opérations sur les polygones. quebec_point &lt;- quebec %&gt;% mutate(st_area = st_area(quebec), st_length = st_length(quebec)) %&gt;% st_centroid() ## Warning in st_centroid.sf(.): st_centroid assumes attributes are constant ## over geometries of x ## Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon = ## of_largest_polygon): st_centroid does not give correct centroids for ## longitude/latitude data plot(quebec_point) ## Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to ## plot all La fonction st_simplify() permet de simplifier les polygones en un nombre réduit de point, ce qui peut être utile pour accélérer les calculs. La fonction st_buffer() permet de créer un rayon d’une longueur donnée autour d’un point, souvent utilisé pour visualiser un rayon d’influence. Mais pour calculer des distances, les données doivent projetées. Nous pouvons les projetées avec st_transform() avec le code ESPG désiré. quebec_point %&gt;% st_transform(3347) %&gt;% st_buffer(50000) %&gt;% # 50 km du centre de la région plot() ## Warning: plotting the first 10 out of 12 attributes; use max.plot = 12 to ## plot all D’autres opérations sur les vecteurs sont offertes et documentées sous la fiche d’aire sf::geos_unary(). Enfin, pour exporter un tableau sf en format csv incluant la géométrie, utilisez st_write(obj = tableau,dsn = &quot;tableau.csv&quot;, layer_options = &quot;GEOMETRY=AS_XY&quot;). Toutefois, si la géométrie n’est pas consituée de points, il faudra préalablement transformer les polygones en points avec st_cast(). st_write(obj = quebec %&gt;% filter(AREA &lt; 1) %&gt;% # ne retenir que quelques régions pour créer un fichier moins volumineux st_cast(&quot;POINT&quot;), dsn = &quot;data/12_quebec_export.csv&quot;, layer_options = &quot;GEOMETRY=AS_XY&quot;) 13.7.2 Données raster Les données rasters sont des grilles, souvent enchâssées dans des images tif géoréférencées. Ces images peuvent comprendre plusieurs variables, que l’on nomme des bandes, en référence aux bandes spectrales des images satélitaires (rouge, vert et bleu). Les données raster peuvent être importées dans votre session grâce à deux fonctions du module raster : raster() importera des données raster à une bande et brick(), des données raster à plusieurs bandes. single band https://assets.datacamp.com/production/repositories/738/datasets/79cb56df0fa27272e16b366a697aba8ac1d3e923/canopy.zip multiband https://assets.datacamp.com/production/repositories/738/datasets/30830f8ba4a60aa1711f41e9a842b22cba3204f3/manhattan.zip library(&quot;raster&quot;) ## Loading required package: sp ## ## Attaching package: &#39;raster&#39; ## The following objects are masked from &#39;package:kernlab&#39;: ## ## buffer, rotated ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract canopy &lt;- raster(&quot;data/12_nytrees/canopy.tif&quot;) canopy ## class : RasterLayer ## dimensions : 230, 253, 58190 (nrow, ncol, ncell) ## resolution : 300, 300 (x, y) ## extent : 1793685, 1869585, 2141805, 2210805 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ## data source : /home/essi/GitHub/ecologie-mathematique-R/data/12_nytrees/canopy.tif ## names : canopy ## values : 0, 255 (min, max) manhattan &lt;- brick(&quot;data/12_nytrees/manhattan/manhattan.tif&quot;) manhattan ## class : RasterBrick ## dimensions : 773, 801, 619173, 3 (nrow, ncol, ncell, nlayers) ## resolution : 29.98979, 30.00062 (x, y) ## extent : 575667.9, 599689.7, 4503277, 4526468 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : /home/essi/GitHub/ecologie-mathematique-R/data/12_nytrees/manhattan/manhattan.tif ## names : manhattan.1, manhattan.2, manhattan.3 ## min values : 0, 0, 0 ## max values : 255, 255, 255 Les informations des objets RasterLayer et RasterBrick peuvent être extraites par les fonctions extent(), ncell(), nlayers() et crs(). La fonction plot() permet d’explorer les données en créant un graphique par bande. plot(manhattan) Les fichiers raster, en format qui viennent souvent en format tif, sont typiquement très volumineux. Si une plus faible résolution convient à une analyse spatiale, on pourra simplifier un raster avec la fonction raster::aggregate() (j’utilise la notation module::fonction() pour éviter la confusion avec la fonction dplyr::aggregate()). L’argument fact est le facteur de conversion et l’argument fun est la fonction d’aggrégation (typiquement mean ou median). manhattan_lowres &lt;- raster::aggregate(manhattan, fact = 20, fun = median) manhattan_lowres ## class : RasterBrick ## dimensions : 39, 41, 1599, 3 (nrow, ncol, ncell, nlayers) ## resolution : 599.7958, 600.0124 (x, y) ## extent : 575667.9, 600259.5, 4503067, 4526468 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## data source : in memory ## names : manhattan.1, manhattan.2, manhattan.3 ## min values : 13, 30, 47 ## max values : 186, 194, 185 plot(manhattan_lowres) Avec un facteur de conversion de 50, nous sommes passés d’une grille de 773 \\(\\times\\) 801 à 16 \\(\\times\\) 17. L’exemple utilisé est volontairement exagéré pour montrer l’effet de la perte de résolution, et généralement le facteur de conversion utilisé est plus faible que 20. La fonction reclassify() est l’équivalent de cut() pour les rasters. L’argument demandé, en plus de l’objet raster, est une matrice de classification à trois colonnes. Les deux premières colonnes spécifient la plage de valeur à classifier et la troisième colonne spécifie la valeur de remplacement (qui peut être NA). La classification s’applique à toutes les couches s’il s’agit d’un RasterBrick. manhattan_rcl &lt;- reclassify(manhattan_lowres, rcl = matrix(c(0, 50, 1, 50, 100, 2, 100, 1000, NA), ncol = 3, byrow = TRUE)) plot(manhattan_rcl) 13.8 Les systèmes de coordonnées Les longitudes et latitudes sont des angles sur un ellipsoïde de révolution. Différentes institutions utilisent différentes formes d’ellipsoïde portant leur nom particulier: NAD83, WGS84, ETRS89, etc. Les projections servent à aplanir des coordonnées géodésiques obtenues selon un ellipsoïde donné en vue de créer des représentations 2D, comme la projection Mercator universelle ou de nombreuses autres. Le système de coordonnées peut être projeté ou non. Système de coordonnées non-projetées: caractérisé par des angles de longitude et de latitudes sur un système géodésique 3D représenté par un ellipsoïde de révolution. Système de coordonnées projetées: caractérisé par des distances X et Y sur une système géodésique représenté en 2D. Lorsque vous utilisez des shapefiles, les informations du système de coordonnées seront incluses dans le fichier ayant une extension prj. Examinons le système de coordonnées du tableau quebec avec la fonction st_crs(). st_crs(quebec) ## Coordinate Reference System: ## EPSG: 4269 ## proj4string: &quot;+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs&quot; D’emblée, la mention +proj=longlat retrouvé dans proj4string (une représentation de PROJ4) indique que le système n’est pas projeté, et que le système géodésique est le GRS80, pratiquement identique au WGS84. Le code ESPG contient la même information que le proj4string. Dans certains cas, les informations du système de coordonnées ne sont pas disponibles et il vous faudra creuser si elles sont essentielles à vos travaux. Pour assigner un système de coordonnées, vous pourrez soit assigner l’ESPG par st_crs(objet_sg) &lt;- 4269 ou le PROJ4 par st_crs(objet_sg) &lt;- &quot;+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs&quot;. La procédure est la même pour les raters, mais avec crs() au lieu de st_crs(). Pour passer d’un système de coordonnées à un autre, utilisez st_transform() pour les vecteurs et projectRasters() pour les rasters. Pour les rasters, si vos données sont catégorielles, et non pas numérique, utilisez method = ngb plutôt que la valeur par défaut, method = bilinear, conçue pour les variables numériques. 13.9 Manipuler des tableaux sf Vous avez peut-être remarqué que j’ai précédemment effectué une opération mutate() en mode pipeline (%&gt;%) sur un tableau sf. Eh oui, les sf sont compatibles avec le mode tidyverse. Vous pourrez filtrer avec filter(), sélectionner avec select() et manipuler des colonnes avec mutate(). Reprenons les données des espèces en danger, mais cette fois-ci nous allons travailler avec des données spatialisées avec sf. D’abord, allons chercher une carte du monde: le format geojson peut être importé de la même manière que des shape files. Puisqu’il s’agit d’un seul fichier (les shapefiles en contiennent plusieurs), on peut l’importer directement d’Internet. world_gj &lt;- st_read(&quot;https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json&quot;) ## Reading layer `countries.geo&#39; from data source `https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json&#39; using driver `GeoJSON&#39; ## Simple feature collection with 180 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -85.60904 xmax: 180 ymax: 83.64513 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs world_gj ## Simple feature collection with 180 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -85.60904 xmax: 180 ymax: 83.64513 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## First 10 features: ## id name geometry ## 1 AFG Afghanistan MULTIPOLYGON (((61.21082 35... ## 2 AGO Angola MULTIPOLYGON (((16.32653 -5... ## 3 ALB Albania MULTIPOLYGON (((20.59025 41... ## 4 ARE United Arab Emirates MULTIPOLYGON (((51.57952 24... ## 5 ARG Argentina MULTIPOLYGON (((-65.5 -55.2... ## 6 ARM Armenia MULTIPOLYGON (((43.58275 41... ## 7 ATA Antarctica MULTIPOLYGON (((-59.57209 -... ## 8 ATF French Southern and Antarctic Lands MULTIPOLYGON (((68.935 -48.... ## 9 AUS Australia MULTIPOLYGON (((145.398 -40... ## 10 AUT Austria MULTIPOLYGON (((16.97967 48... Des multipolygones sont formés lorsque plusieurs polygones forment une seule entité, par exemple un pays constitué de plusieurs îles. Nous allons effectué la jointure entre le tableau world_gj et les données de l’IUCN. De même que précédemment, les noms des pays doivent correspondre exactement. iucn_oecd &lt;- iucn_oecd %&gt;% replace(.==&quot;USA&quot;, &quot;United States of America&quot;) %&gt;% replace(.==&quot;UK&quot;, &quot;United Kingdom&quot;) %&gt;% rename(&quot;name&quot; = &quot;region&quot;) Pour cette jointure, je désire ne conserver que les données géographiques des pays de l’OCDE. Je peux effectuer une jointure à gauche sur le tableau iucn_oecd ou une joiture à droite sur le tableau world_gj. oecd_gj &lt;- world_gj %&gt;% right_join(iucn_oecd, by = &quot;name&quot;) ## Warning: Column `name` joining factor and character vector, coercing into ## character vector Contrairement aux tableaux tibble, le format sf conserve la géométrie. oecd_gj %&gt;% dplyr::select(name, n_threatened_species) ## Simple feature collection with 39 features and 2 fields (with 1 geometry empty) ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -55.61183 xmax: 180 ymax: 83.23324 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## First 10 features: ## name n_threatened_species ## 1 Czech Republic 7567 ## 2 United States of America 6005 ## 3 Germany 5039 ## 4 Slovakia 2927 ## 5 Austria 2826 ## 6 Switzerland 2571 ## 7 Japan 2497 ## 8 Poland 2308 ## 9 Finland 2011 ## 10 Canada 1943 ## geometry ## 1 MULTIPOLYGON (((16.96029 48... ## 2 MULTIPOLYGON (((-155.5421 1... ## 3 MULTIPOLYGON (((9.921906 54... ## 4 MULTIPOLYGON (((18.85314 49... ## 5 MULTIPOLYGON (((16.97967 48... ## 6 MULTIPOLYGON (((9.594226 47... ## 7 MULTIPOLYGON (((134.6384 34... ## 8 MULTIPOLYGON (((15.017 51.1... ## 9 MULTIPOLYGON (((28.59193 69... ## 10 MULTIPOLYGON (((-63.6645 46... Pour une raison ou une autre, si vous désirex retirer la géométrie, oecd_gj %&gt;% dplyr::select(name, n_threatened_species) %&gt;% st_set_geometry(NULL) ## name n_threatened_species ## 1 Czech Republic 7567 ## 2 United States of America 6005 ## 3 Germany 5039 ## 4 Slovakia 2927 ## 5 Austria 2826 ## 6 Switzerland 2571 ## 7 Japan 2497 ## 8 Poland 2308 ## 9 Finland 2011 ## 10 Canada 1943 ## 11 Norway 1898 ## 12 Italy 1852 ## 13 Spain 1766 ## 14 Belgium 1765 ## 15 Australia 1752 ## 16 Brazil 1579 ## 17 Mexico 1466 ## 18 Colombia 1443 ## 19 Turkey 1421 ## 20 Denmark 994 ## 21 France 887 ## 22 United Kingdom 879 ## 23 Netherlands 796 ## 24 Chile 785 ## 25 Slovenia 608 ## 26 Korea 559 ## 27 Hungary 550 ## 28 Ireland 540 ## 29 Estonia 502 ## 30 Greece 487 ## 31 Latvia 427 ## 32 Luxembourg 414 ## 33 Sweden 384 ## 34 New Zealand 378 ## 35 Russia 345 ## 36 Lithuania 267 ## 37 Costa Rica 228 ## 38 Portugal 176 ## 39 Iceland 85 On pourra explorer notre tableau avec la fonction plot(). plot(oecd_gj) Tout comme on effectue des jointures entre des tableaux, on peut effectuerd es jointures spatiales sur des sf. On pourra trouver des intersections entre polygones, effectuer des unions, des différences, etc. Par exemple, en modélisation, il est commun d’extrapoler des résultats sur une grille. Ici, nous créons une grille couvrant tout le québec. Nous créons une grille constituée des centroïdes, %&gt;% # (par défaut, il s’agit d’une grille de polygones rectangulaires) nous transformons le résultat en format sf (au lieu de sfc), %&gt;% nous effectuons une jointure sous forme d’intersection et %&gt;% nous retirons les occurences hors de la jointure. quebec_grid &lt;- quebec %&gt;% st_make_grid(n = 80, what = &quot;centers&quot;) %&gt;% st_sf() %&gt;% # transformer en objet sf st_join(quebec, join = st_intersects) %&gt;% drop_na() ## although coordinates are longitude/latitude, st_intersects assumes that they are planar par(mfrow = c(1, 2)) plot(quebec_grid %&gt;% st_geometry(), pch = 16, cex = 0.2, main = &quot;Grille Québec&quot;) plot(quebec_grid %&gt;% filter(RES_NM_REG == &quot;Montérégie&quot;) %&gt;% st_geometry(), main = &quot;Grille Montérégie&quot;) Pour soutirer la grille en vue de modéliser, quebec_grid %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% rename(&quot;lon&quot; = &quot;X&quot;, &quot;lat&quot; = &quot;Y&quot;) ## # A tibble: 3,636 x 2 ## lon lat ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -74.2 45.1 ## 2 -73.9 45.1 ## 3 -73.6 45.1 ## 4 -73.3 45.1 ## 5 -73.1 45.1 ## 6 -72.8 45.1 ## 7 -72.5 45.1 ## 8 -72.2 45.1 ## 9 -71.9 45.1 ## 10 -71.6 45.1 ## # … with 3,626 more rows 13.10 Manipuler des objets raster Comme les objets vectoriels, les objets raster peuvent subir différents types d’opérations. Nous en couvrirons trois. Masque (mask()): l’intersection entre un polygone et un raster. Découper (crop()): découpe rectangulaire selon les limites de l’objet. Extraction (extract()): extrait, et accessoirement effectue un sommaire, des rasters dans un polygone donné Créons d’abord un polygone ayant le même système de coordonnées que le raster canopy. poly &lt;- st_sfc(st_polygon(list(cbind(c(1800000, 1830000, 1820000, 1800000), c(2160000, 2200000, 2150000, 2160000))))) %&gt;% st_set_crs(as.character(crs(canopy))) %&gt;% st_cast(&quot;POLYGON&quot;) En ce moment, le module raster n’est pas adapté au format sf, qu’il faudrait préalablement convertir vers l’ancien format sp. poly_sp &lt;- as(poly, &quot;Spatial&quot;) Appliquons un masque, puis un crop, puis les deux. canopy_mask &lt;- mask(canopy, mask = poly_sp) canopy_crop &lt;- crop(canopy, y = poly_sp) canopy_mc &lt;- crop(canopy_mask, y = poly_sp) par(mfrow = c(1, 4)) plot(canopy, main = &quot;Original&quot;) plot(poly_sp, add = TRUE) plot(canopy_mask, main = &quot;mask()&quot;) plot(poly_sp, add = TRUE) plot(canopy_crop, main = &quot;crop()&quot;) plot(poly_sp, add = TRUE) plot(canopy_mc, main = &quot;mask() &amp; crop()&quot;) plot(poly_sp, add = TRUE) Pour effectuer un calcul sur l’intérieur du polygone avec extract()… on spécifie le raster, le polygone et la fonction! extract(canopy, poly_sp, fun = mean) ## [,1] ## [1,] 10.51405 13.11 Graphiques d’objets spatialisés Pour afficher les objets sf et raster, nous avons utilisé les fonctions de base à titre exploratoire. Mais lorsque vient le temps de publier une carte, la trousse de ggplot2 est toute indiquée, en y ajoutant l’outil geom_sf(). ggplot(quebec) + geom_sf(aes(fill = RES_NM_REG)) + geom_sf(data = quebec_point) Les coordonnées peuvent être manipulées avec coord_sf(). world_gj_iucn &lt;- world_gj %&gt;% full_join(iucn_oecd, by = &quot;name&quot;) ## Warning: Column `name` joining factor and character vector, coercing into ## character vector ggplot(world_gj_iucn) + geom_sf(aes(fill = n_threatened_species), colour = &quot;gray50&quot;) + coord_sf(xlim = c(-170, -40), ylim = c(10, 80)) + scale_fill_gradient(low = &quot;#8CBFE6&quot;, high = &quot;#FF0099&quot;, na.value = &quot;grey80&quot;) + labs(title = &quot;Number of threatened species in OECD countries&quot;, subtitle = &quot;Source: OCDE, 2019&quot;) + guides(fill = guide_legend(title = &quot;Number of\\nthreatened\\nspecies&quot;)) Les cartes thématiques de tmap (thematic maps). Différents types de projections sont disponibles avec différentes palettes de couleurs (palette_explorer()). library(&quot;tmap&quot;) library(&quot;tmaptools&quot;) tm_shape(set_projection(world_gj_iucn, &quot;wintri&quot;)) + tm_polygons(&quot;n_threatened_species&quot;, palette = &quot;viridis&quot;) ## OGR: Corrupt data ## OGR: Corrupt data ## Warning in st_is_longlat(x): bounding box has potentially an invalid value ## range for longlat data ## OGR: Corrupt data ## OGR: Corrupt data Si vous désirez créer des cartes intéractives, passez en mode leaflet en spécifiant tmap_mode(&quot;view&quot;) (pour revenir en mode statique, tmap_mode(&quot;plot&quot;)) tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(world_gj_iucn) + tm_polygons(&quot;n_threatened_species&quot;, palette = &quot;viridis&quot;) Petit exemple avec des facettes synchronisées. tm_shape(quebec) + tm_polygons(c(&quot;AREA&quot;, &quot;PERIMETER&quot;)) + tm_facets(sync = TRUE, ncol = 2) 13.12 Ressources complémentaires https://geocompr.robinlovelace.net/ https://www.rspatial.org/ https://r-spatial.github.io/sf/index.html "]
]

[
["chapitre-geo.html", "13 Les données géospatiales 13.1 Les données spatiales 13.2 Le module ggmap 13.3 Types de données spatiales", " 13 Les données géospatiales ️ Objectifs spécifiques: À la fin de ce chapitre, vous serez familiers avec les notions de base géomatique: systèmes géodésiques, projections et données géoréférencées saurez utiliser R comme outil d’analyse spatiale (donnée associées à des points, lignes, polygones) saurez cartographier des données géoréférencées avec ggplot et Leaflet serez en mesure d’effectuer un autoapprentissage spatial avec les techniques des k-proches voisins et les processus gaussiens serez aptes à aborder une analyse géostatistique serez aptes à aborder une modélisation de distribution des espèces 13.1 Les données spatiales Des données associées à un endroit sont spatiales. Puisque ce cours ne traite pas d’écologie exoplanétaire, nous traiterons en particulier de données géospatiales, mot que l’on utilise pour désigner des données avec référence spatiale sur la planète Terre. Lorsque nous avons abordé les séries temporelles, j’ai pris pour acquis que nous utilisions le calendrier grégorien comme référence temporelle. Pour les données géospatiales, nous utilisons souvent des angles donnant la position à la surface d’un ellipsoide de révolution (le système géodésique): la longitude décrivant l’angle de part et d’autre (entre 0° et 180° Ouest ou Est) du méridien de référence (le premier méridien, près de Greenwich) et la latitude décrivant l’angle entre l’équateur et l’un des pôles (entre 0° et 90° Nord ou Sud). Les angles sont parfois exprimées sous forme degré° minute' seconde'' Sens cardinal, par exemple 46° 53' 21.659'' S. Toutefois, il est plus commun (et plus pratique) d’exprimer les angles de manière décimale, accompagnée d’un signe pour indiquer le sens cardinal (par convention positif au Nord et à l’Est). Par exemple, sous forme: \\[ secondes = \\frac{21.659&#39;&#39;}{3600&#39;&#39; \\cdot °^{-1}} = 0.00602° \\] \\[ minutes = \\frac{53&#39;}{60&#39; \\cdot °^{-1}} = 0.883° \\] \\[ - \\left( 46° + 0.883° + 0.00602° \\right) = -46.889° \\] La référence de l’altitude est généralement donnée par rapport à un géoïde, qui est une élévation théorique du niveau de la mer ainsi qu’une direction de la gravité évaluée sur toute la surface du globe. Les angles ne sont pas pratiques pour mesurer des distances. Ainsi, pour présenter la Terre sous forme de carte, on cré des représentations applaties du globe sous forme de carte avec l’aide d’équations de projection. Or, il existe différents systèmes géodésiques, différents géoides et de nombreuses manières de calculer les projections. Ainsi, il est important de spécifier les références utilisées lorsque l’on donne dans la précision. Néanmoins, je prendrai pour acquis que vous possédez certaines bases en positionnement, qui ne sont pas essentielles pour suivre le cours, mais qui le sont pour pratiquer adéquatement un métier scientifique. Dans ce chapitre, j’utiliserai comme exemple d’application des donnes météorologiques soutirées d’Environnement Canada grâce au module weathercan, obtenues entre les longitudes -60° et -80° et entre les latitudes 45° et 50° en mai 2018. J’ai effectué quelques opérations pour obtenir des indicateurs météo: degrés-jour (somme des degrés de température moyenne &gt; 5 °C, degree_days), précipitations totales (cumul_precip) et indice de diversité des précipitations (plus l’indice sdi s’approche de 1, plus les températures sont uniformément distribuées pendant la période). Les calculs sont consignés dans le fichier lib/12_weather-fetch.R, mais étant donné que le téléchargement prend pas mal de temps, j’ai créé un csv. Les coordonnées se trouves dans les colonnes de latitude (lat) et longitude (lon). library(&quot;tidyverse&quot;) ## ── Attaching packages ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.1.0 ✔ purrr 0.3.2 ## ✔ tibble 2.1.1 ✔ dplyr 0.8.0.1 ## ✔ tidyr 0.8.3 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() source(&quot;lib/12_weather-fetch.R&quot;) weather &lt;- read_csv(&quot;data/12_weather.csv&quot;) ## Parsed with column specification: ## cols( ## station_id = col_double(), ## station_name = col_character(), ## prov = col_character(), ## lat = col_double(), ## lon = col_double(), ## degree_days = col_double(), ## cumul_precip = col_double(), ## sdi = col_double() ## ) weather %&gt;% head() ## # A tibble: 6 x 8 ## station_id station_name prov lat lon degree_days cumul_precip sdi ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10247 ILE AUX GRU… QC 47.1 -70.5 NA NA NA ## 2 10661 NORTHEAST M… NS 46.4 -61.0 372. 222. 0.904 ## 3 10732 NICOLET QC 46.2 -72.7 823. 78.4 0.704 ## 4 10761 MCTAVISH QC 45.5 -73.6 915. 107 0.740 ## 5 10762 STE-CLOTILDE QC 45.2 -73.7 860. 85.2 0.820 ## 6 10763 ILES DE LA … QC 47.4 -61.8 326. 167. 0.853 Dans le tableau weather, chaque observation est liée à un point dans l’espace. Dans ce cas, nous avons tous les outils nécessaires pour afficher nos points dans l’espace. weather %&gt;% ggplot(mapping = aes(x = lon, y = lat)) + geom_point() Si vous avez un oeil averti, vous avez peut-être repéré le Québec, le Nouveau-Brunswick et la frontière avec les États-Unis. L’absence de repère rend néanmoins difficle l’interprétation de cette carte. 13.2 Le module ggmap Le module ggmap ajoute des couches d’images téléchargées depuis des services de cartorgaphie en ligne. Dans cette section, nous allons utiliser le serveice de carte Stamen, qui ne demande pas de frais d’utilisation ou d’enregistrement particulier. La fonction get_stamenmap() demande une boîte de coordonnées délimitant la carte à produire, un paramètre de zoom (plus le zoom est petit, plus on cherche une carte couvrant un grand territoire) et accessoirement un type de carte. library(&quot;ggmap&quot;) ## Google&#39;s Terms of Service: https://cloud.google.com/maps-platform/terms/. ## Please cite ggmap if you use it! See citation(&quot;ggmap&quot;) for details. east_canada &lt;- get_stamenmap(bbox = c(left=-81, right = -59, bottom = 44, top = 51), zoom = 6, maptype = &quot;terrain&quot;) ## Source : http://tile.stamen.com/terrain/6/17/21.png ## Source : http://tile.stamen.com/terrain/6/18/21.png ## Source : http://tile.stamen.com/terrain/6/19/21.png ## Source : http://tile.stamen.com/terrain/6/20/21.png ## Source : http://tile.stamen.com/terrain/6/21/21.png ## Source : http://tile.stamen.com/terrain/6/17/22.png ## Source : http://tile.stamen.com/terrain/6/18/22.png ## Source : http://tile.stamen.com/terrain/6/19/22.png ## Source : http://tile.stamen.com/terrain/6/20/22.png ## Source : http://tile.stamen.com/terrain/6/21/22.png ## Source : http://tile.stamen.com/terrain/6/17/23.png ## Source : http://tile.stamen.com/terrain/6/18/23.png ## Source : http://tile.stamen.com/terrain/6/19/23.png ## Source : http://tile.stamen.com/terrain/6/20/23.png ## Source : http://tile.stamen.com/terrain/6/21/23.png Pour afficher la carte, nous enchâssons notre objet dans une fonction ggmap(), à laquelle nous pouvons ajouter une couche. ggmap(east_canada) + geom_point(data = weather, mapping = aes(x = lon, y = lat)) Une approche plus généraliste consiste à spécifier dans la fonction ggmap() l’agument de base utilisé pour lancer un graphique ggplot, comme ceci. ggmap(east_canada, base_layer = ggplot(weather, aes(x = lon, y = lat))) + geom_point() L’utiliation de l’argument base_layer permet d’effectuer des fecettes et d’éviter de spécifier la source des données dans toutes les couches subséquentes. La carte que nous avons créée est de type terrain, un type d’affichage efficace mais peu approprié pour une publication visant à être imprimée. Le type toner-lite est davantage voué à l’impression, alors que le type watercolor est plus joli pour le web. Les types offerts sont listés dans la ficher d’aide ?get_stamenmap. maptype = c(&quot;terrain&quot;, &quot;terrain-background&quot;, &quot;terrain-labels&quot;, &quot;terrain-lines&quot;, &quot;toner&quot;, &quot;toner-2010&quot;, &quot;toner-2011&quot;, &quot;toner-background&quot;, &quot;toner-hybrid&quot;, &quot;toner-labels&quot;, &quot;toner-lines&quot;, &quot;toner-lite&quot;, &quot;watercolor&quot;) 13.3 Types de données spatiales Nous avons jusqu’à présent utilisé des données spatiales attchées à un point. Ce ne sont pas les seuls. Données ponctuelles: associées à un point. Exemple: mesure à un endroit précis. Données linéaires: associées à une série de point. Exemple: mesure associée à une route ou une rivière. Données de polygone: associées à une aire délimitée par des points. Exemples: Données associées à un champ, une unité administrative, un bassin versant, etc. Données raster: associées à une grille. Exemple: une image satellite où chaque pixel est associé à un recouvrement foliaire. L’enregistrement des données ponctuelles ne posent pas de défi particulier. Les données associées à un ligne, toutefois posent un problème d’organisation, puisqu’une ligne elle-même contient des informations sur les coordonnées de ses points ainsi que l’ordre dans lequel les points sont connectés. On pourra soit créer un tableau de données ayant une colonne où l’identifiant de la line est consigné, renvoyant à un autre tableau où chaque ligne décrit un point en terme d’identifiant de ligne à laquelle il appartient, ses coordonnées, ainsi que sont ordre de rattachement dans la ligne. Les informations de la ligne pourraient aussi être enchâssées dans une cellule de tableau de données, en tant que sous-tableau. Ou bien, on pourrait créer un tableau sous forme de jointure entre le tableau des données et le tableau des lignes. Un défi similaire pourrait subvenir avec des polygones, qui demandent davantage d’information étant donnée qu’ils peuvent être troués ou séparés en différents morceaux. Enfin, il existe des formats de données spatiales génériques (shape files et geojson) ou spécialement conçus pour R (notamment offerts par le module sp), mais nous les couvrirons pas dans dans l’édition actuelle de ce chapitre. La fonction map_data() de ggplot2 crée des cartes Les cartes de type choroplèthe se présente sous forme de polygones décrits par un groupe et un ordre. Les pays, par exemple, forment des polygones. world &lt;- map_data(map = &quot;world&quot;) # jeu de donneés de ggplot2 ## ## Attaching package: &#39;maps&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## map head(world) ## long lat group order region subregion ## 1 -69.89912 12.45200 1 1 Aruba &lt;NA&gt; ## 2 -69.89571 12.42300 1 2 Aruba &lt;NA&gt; ## 3 -69.94219 12.43853 1 3 Aruba &lt;NA&gt; ## 4 -70.00415 12.50049 1 4 Aruba &lt;NA&gt; ## 5 -70.06612 12.54697 1 5 Aruba &lt;NA&gt; ## 6 -70.05088 12.59707 1 6 Aruba &lt;NA&gt; La plupart du temps, il est préférable de démarrer une carte faite de polygone à partir de données existantes. Souvent, ces polygones ne sont pas déjà inclus en R. Dans ce cas, il faudra trouver des fichiers de carte auprès de Statistique Canada, Données Québec, etc. Dans notre cas, nous allons associé à ce tableau la production de canneberge des 3 plus grands producteurs mondiaux. # source des données: https://www.cranberryinstitute.org/about_cran/Cropstatistics_about.html cranberry_prod &lt;- tibble(region = c(&quot;Chile&quot;, &quot;Canada&quot;, &quot;USA&quot;), cranberry_production = c(44000, 406393, 861517)) cran_world &lt;- world %&gt;% left_join(cranberry_prod, by = &quot;region&quot;) La stratégie est de créer des polygones groupés par région, dont la couleur de remplissage correspond à la production de canneberge. Nou ajoutons coord_map() en spécifiant une projection de type Mercator (essayez projection = &quot;ortho&quot;). Le reste est de la décoration. ggplot(cran_world, aes(long, lat)) + geom_polygon(aes(fill = factor(cranberry_production), group = group), colour = &quot;grey30&quot;, lwd = 0.1) + coord_map(projection = &quot;mercator&quot;, xlim = c(-180, 180), clip = &quot;off&quot;) + #scale_fill_gradient(low = &quot;pink&quot;, high = &quot;red&quot;, na.value = &quot;grey60&quot;) + theme(panel.background = element_rect(fill = &quot;white&quot;), plot.background = element_rect(fill = &quot;white&quot;), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), panel.grid = element_blank()) + guides(fill = guide_legend(title = &quot;Cranberry\\nproduction&quot;)) Prédiction spatiale: - https://www.sciencedirect.com/science/article/pii/S2211675316300033 - https://stackoverflow.com/questions/43618633/multi-output-spatial-statistics-with-gaussian-processes download.file(&quot;http://www12.statcan.gc.ca/census-recensement/2011/geo/bound-limit/files-fichiers/2016/ldr_000b16a_f.zip&quot;, destfile=&quot;data/12_ldr_000b16a_f.zip&quot;) unzip(&quot;data/12_ldr_000b16a_f.zip&quot;, exdir = &quot;data/12_canada/&quot;) canada &lt;- rgdal::readOGR(&quot;data/12_canada&quot;, &quot;ldr_000b16a_f&quot;) map_areas &lt;- data.frame(id=canada@data$DRNOM, area=sapply(slot(canada, &quot;polygons&quot;), slot, &quot;area&quot;) ) canada_map &lt;- fortify(canada, region=&quot;DRNOM&quot;) "]
]
